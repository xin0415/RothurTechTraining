OSI Model and TCP/IP Model
    OSI Model
        Open System Interconnection, 7 layer
            - application layer: Http, FTP, SMTP, DNS
            - presentation layer: encryption/decryption
            - session layer: sockets
            - transport layer: TCP and UDP
            - network layer: IP
            - data link layer: format of data
            - physical layer: raw bit
    TCP/IP Model
        - application layer     -   contains application layer, presentation layer, session layer
        - transport layer       -   transport layer
        - internet layer        -   network layer
        - network access layer  -   data link layer and physical layer

            client              ---------------------http-------------------------->        server
web browser/mobile/IOT device   <--------------------http---------------------------


HTTP (Hypertext Transfer Protocol)
    - client-server model
    - Http Request
        - header/ body
    - Http Response
        - header / body
    - http method:
        get: read                |   safe    |     idempotent      |    cacheable      |            get is safe, so it is cacheable, this setup can be changed
        post: create             | not safe  |  not idempotent     |   not cacheable   |
        put: whole update        | not safe  |     idempotent      |   not cacheable   |
        delete: remove           | not safe  |     idempotent      |   not cacheable   |            is will leave database empty, so it is idempotent
        patch: partial update    | not safe  |  not idempotent (can be) |   not cacheable   |       patch will flexibility, you don't need pass whole object, we can also pass operation {operation:"add", targetField:age} to cause patch is not idempotent
    - http status code
        1xx information         providing some base information
        2xx success
        3xx redirection
        4xx client error
        5xx server error

HTTP advanced
    safe, a http method is safe if it doesn't alter(change) the state of the server
    idempotent: a http method is idempotent if an identical request can be made once or several times in a row
                with the same effect while leaving the server in the same state
                idempotent: send the multiple request, but keep the same status in servers
                create resource in server and adding row into database, that is not idempotent
    cacheable
        - whether response can be cached        - store information in somewhere. can be your local brows or server side(session)

        post request: create a user (2, Mali, CA, 18)
        patch request: {operation: "add", targetField: age}
        id name address age
        (2, Tom, CA, 23)

    http status code
        200 OK
        201 created
        202 Accepted
        204 No content
        307 temporary redirect
        301 moved permanently
        400 bad request
        401 unauthorized
        403 forbidden               user doesn't have permission
        404 not found
        500 internal server error
        200 is OK, the request is success
        201 is created the request to creation is success
        202 is Accepted the request has been accepted for processing, but the processing is not complete
        204 is not content. The server successfully processed the request, but not returning content
        307 is temporary redirect. The request redirect to another URL
        301 moved permanently The URL has been changed permanently
        400 is bad request	the server could not understand the request
        401 is unauthorized the client must authenticate itself
        403 is forbidden, the client doesn’t have permission to access
        404 is page not found, client cannot find the page
        500 is internal server error, error happens in backend and doesn’t know how to handle



TCP and UDP,
    TCP - check if receive all the packet       send packets (1-100) to server, but server only receive (1-78,80-100), TCP will resubmit 79 package -lower speed
    UDP - may lost package  - high speed because it doesn't check all the packages are received
    difference
    TCP 3 way handshaking / 4 way handshaking
    3 way handshaking
    - SYN (Synchronize): The client sends a SYN segment to the server to initiate the connection with the SYN flag set: client ->server:[SYN, seq=x]   -
    - SYN-ACK (Synchronize-Acknowledge): the server responds with a SYN-ACK segment to acknowledge the client's request and provide its own synchronization information that has both the SYN and ACK flag set: Server ->Client:[SYN, ACK, Seq =y, Ack=x+1]
    - ACK (Acknowledge): the client send an ACK segment to acknowledge the server's response, completing the handshake: Client -> Server:[ACK,Seq=x+1, Ack=y+1]
    4 way handshaking
    - FIN (Finish): The initiator sends a FIN segment to singal the termination of the connection: Client -> Server: [FIN, Seq=x]
    - ACK (Acknowledge): The receiver responds with an ACK segment to acknowledge the FIN: Server -> Client: [ACK, Seq=y, ACK=x+1]
    - FIN (Finish): The receiver send its own FIN segment to singal the termination of the connection in the opposite direction: Server -> Client:[FIN seq=z]
    - ACK (Acknowledge): The initiator responds with an ACK segment to acknowledge the second FIN, completing the termination process: Client->Server:[ACK, Seq=x+1, Ack=z+1]

Session and Cookie
    - Cookie: client side,
    - Session: Server side, implements HttpSession interface


Java Web Application Architecture
    - Tomcat/ Jboss/ Jetty/ Apache TomEE....

Three Tier Architecture
    - controller / Service/ DAO(repository layer)

____________________ Spring ___________________________________
Spring IOC
    Inversion of control


public class Store {
    private Item item;
    public Store() {
        this.item = new ItemImpl("Desk");
    }
}

public class Store {
    private Item item;
    public Store(Item item) {
        this.item = item;
    }
}


class AnotherCLass {
    public static void main(String[] args) {
        Item item = new Item(fields);
        Store store = new Store(item);
    }
}

DI (dependency Injection)

------------------------ tomcat
Client (Browser)
       |
       v
+----------------+
|  Coyote        |  <-- HTTP Connector (handles incoming requests)
+----------------+
       |
       v
+----------------+
|  Catalina      |  <-- Servlet Container (manages servlets and JSPs)
+----------------+
       |
       v
+----------------+
|  Jasper        |  <-- JSP Engine (compiles and processes JSP files)
+----------------+
       |
       v
+----------------+
|  Web Apps      |  <-- Context (individual web applications)
+----------------+
--------------------join point
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethodExecution(JoinPoint joinPoint) {
        System.out.println("Executing method: " + joinPoint.getSignature().getName());
        Object[] args = joinPoint.getArgs();
        for (Object arg : args) {
            System.out.println("Argument: " + arg);
        }
    }
}
In this example, the logBeforeMethodExecution method is an advice that runs before the execution of any method in the com.example.service package. The JoinPoint parameter provides access to the method signature and its arguments.
---------------------aspect
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class PerformanceAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethodExecution() {
        System.out.println("Before method execution");
    }

    @AfterReturning(pointcut = "execution(* com.example.service.*.*(..))", returning = "result")
    public void logAfterMethodExecution(Object result) {
        System.out.println("After method execution, result: " + result);
    }
}
The PerformanceAspect class is an aspect containing two advices.
The logBeforeMethodExecution method runs before any method in the com.example.service package is executed.
The logAfterMethodExecution method runs after the method execution and logs the returned result.
--------------------------AOP
JoinPoint: A point during the execution of a program, such as the execution of a method or the handling of an exception.

Aspect: A class containing cross-cutting concerns (advice) that can be applied at various join points.

Advice: The action taken by an aspect at a particular join point. Spring AOP supports different types of advice:
    - @Before: Runs before the method execution.
    - @After: Runs after the method execution.
    - @AfterReturning: Runs after the method execution only if it completes successfully.
    - @AfterThrowing: Runs after the method execution only if it exits by throwing an exception.
    - @Around: Runs before and after the method execution.

Pointcut: A predicate that matches join points. It specifies where advice should be applied. Pointcuts can be defined using expressions or annotations.

Weaving: The process of applying aspects to a target object to create a new proxy object. In Spring AOP, weaving is done at runtime.
















